/*
 * Frontend Service
 *
 * Frontend Microservice for the Gi√≤ Plants platform.
 *
 * API version: 1.0.0
 * Contact: andrea.liut@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package api

import (
	"encoding/json"
	"fmt"
	"gio-frontend-ms/pkg/model"
	"gio-frontend-ms/pkg/repository"
	"github.com/gorilla/mux"
	"html/template"
	"log"
	"net/http"
	"sort"
)

var templates = template.Must(template.ParseGlob("static/html/*"))

func ListRooms(w http.ResponseWriter, _ *http.Request) {
	repo, _ := repository.NewRoomRepository()
	rooms, err := repo.GetAll()

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, "Cannot retrieve rooms")
		return
	}

	w.WriteHeader(http.StatusOK)

	data := ListRoomsPageData{
		Title: "Rooms",
		Rooms: rooms,
	}

	if err := templates.ExecuteTemplate(w, "rooms_list.html", data); err != nil {
		log.Println(err)
	}
}

func GetRoom(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	roomId := vars["roomId"]

	repo, _ := repository.NewRoomRepository()
	room, err := repo.Get(roomId)

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, "Cannot retrieve room")
		return
	}

	if room == nil {
		errorHandler(w, http.StatusNotFound, "room not found")
		return
	}

	w.WriteHeader(http.StatusOK)

	data := RoomPageData{
		Title: "Room",
		Room:  room,
	}

	if err := templates.ExecuteTemplate(w, "room.html", data); err != nil {
		log.Println(err)
	}
}

func ListDevices(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	roomId := vars["roomId"]

	repo, _ := repository.NewDeviceRepository()
	devices, err := repo.GetAll(roomId)

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, "Cannot retrieve devices")
		return
	}

	if devices == nil {
		errorHandler(w, http.StatusNotFound, "room not found")
		return
	}

	w.WriteHeader(http.StatusOK)

	data := ListDevicesPageData{
		Title:   fmt.Sprintf("Devices of room %s", roomId),
		Devices: devices,
	}

	if err := templates.ExecuteTemplate(w, "devices_list.html", data); err != nil {
		log.Println(err)
	}
}

func GetDevice(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	roomId := vars["roomId"]
	deviceId := vars["deviceId"]

	repo, _ := repository.NewDeviceRepository()
	device, err := repo.Get(roomId, deviceId)

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, "Cannot retrieve devices")
		return
	}

	if device == nil {
		errorHandler(w, http.StatusNotFound, "Device not found")
		return
	}

	readings, err := repo.GetReadings(roomId, deviceId, -1, "")
	errorMessage := ""
	if err != nil {
		errorMessage = err.Error()
		readings = []model.Reading{}
	}

	sort.Sort(model.ByCreationTimestamp(readings))

	w.WriteHeader(http.StatusOK)

	data := DevicePageData{
		Title:        "Device",
		Device:       device,
		Readings:     readings,
		ErrorMessage: errorMessage,
	}

	if err := templates.ExecuteTemplate(w, "device.html", data); err != nil {
		log.Println(err)
	}
}

func getActionData(r *http.Request) *model.ActionData {
	var actionData model.ActionData
	err := json.NewDecoder(r.Body).Decode(&actionData)
	if err != nil {
		return nil
	}

	return &actionData
}

func TriggerAction(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	roomId := vars["roomId"]
	deviceId := vars["deviceId"]
	actionName := vars["actionName"]

	log.Printf("TriggerDeviceAction called: %s", actionName)

	actionData := getActionData(r)
	if actionData == nil {
		log.Printf("WARNING: no data passed for action %s", actionName)
	}

	repo, _ := repository.NewDeviceRepository()
	device, err := repo.Get(roomId, deviceId)

	if err != nil {
		errorHandler(w, http.StatusInternalServerError, "Cannot retrieve devices")
		return
	}

	if device == nil {
		errorHandler(w, http.StatusNotFound, "Device not found")
		return
	}

	err = repo.TriggerAction(roomId, deviceId, actionName, actionData)

	message := "Action triggered successfully"
	code := http.StatusOK
	if err != nil {
		message = err.Error()
		code = http.StatusInternalServerError
	}

	m := model.ApiResponse{
		Code:    code,
		Message: message,
	}

	w.WriteHeader(code)
	if err := json.NewEncoder(w).Encode(m); err != nil {
		log.Println(err)
	}
}
